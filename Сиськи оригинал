"use strict";

class Stage {
    // ... (код Stage остается прежним из твоего исходника)
    constructor() {
        this.container = document.getElementById('game');
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor('#D0CBC7', 1);
        this.container.appendChild(this.renderer.domElement);
        this.scene = new THREE.Scene();
        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
        this.camera.position.set(2, 2, 2);
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);
        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);
        window.addEventListener('resize', () => this.onResize());
        this.onResize();
    }
    render() { this.renderer.render(this.scene, this.camera); }
    add(elem) { this.scene.add(elem); }
    remove(elem) { this.scene.remove(elem); }
    onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        let aspect = window.innerWidth / window.innerHeight;
        this.camera.left = aspect * viewSize / -2;
        this.camera.right = aspect * viewSize / 2;
        this.camera.top = viewSize / 2;
        this.camera.bottom = viewSize / -2;
        this.camera.updateProjectionMatrix();
    }
}

class Block {
    // ... (код Block остается прежним)
    constructor(targetBlock) {
        this.targetBlock = targetBlock;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 === 0 ? 'x' : 'z';
        this.workingDimension = this.index % 2 === 0 ? 'width' : 'depth';
        this.dimension = {
            width: targetBlock ? targetBlock.dimension.width : 10,
            height: 2,
            depth: targetBlock ? targetBlock.dimension.depth : 10
        };
        this.position = {
            x: targetBlock ? targetBlock.position.x : 0,
            y: this.index * 2,
            z: targetBlock ? targetBlock.position.z : 0
        };
        this.color = new THREE.Color(`hsl(${30 + this.index * 4}, 100%, 50%)`);
        this.mesh = new THREE.Mesh(
            new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth),
            new THREE.MeshPhongMaterial({ color: this.color })
        );
        this.mesh.position.set(this.position.x, this.position.y, this.position.z);
        this.speed = -0.1 - (this.index * 0.005);
        if (this.speed < -0.4) this.speed = -0.4;
        this.direction = this.index % 2 === 0 ? this.speed : -this.speed;
        if (this.index > 1) {
            this.position[this.workingPlane] = (this.index % 2 === 0 ? 15 : -15);
        }
    }
    tick() {
        if (this.index > 1) {
            this.position[this.workingPlane] += this.direction;
            this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
            if (Math.abs(this.position[this.workingPlane]) > 15) this.direction *= -1;
        }
    }
}

class Game {
    constructor() {
        this.STATES = { READY: 'ready', PLAYING: 'playing', ENDED: 'ended' };
        this.state = this.STATES.READY;
        this.stage = new Stage();
        this.mainContainer = document.getElementById('container');
        this.scoreContainer = document.getElementById('score');
        this.startButton = document.getElementById('start-button');
        
        // --- ЗВУКИ ---
        this.sounds = {
            music: new Audio('music.mp3'),
            place: new Audio('place.mp3'),
            fail: new Audio('fail.mp3')
        };
        this.sounds.music.loop = true;
        this.sounds.music.volume = 0.4;
        // --------------

        this.blocks = [];
        this.init();
        
        this.startButton.addEventListener('click', () => this.startGame());
        this.mainContainer.addEventListener('mousedown', () => this.handleAction());
        window.addEventListener('keydown', e => { if(e.keyCode === 32) this.handleAction(); });
        
        this.tick();
    }

    init() {
        this.blocks.forEach(b => this.stage.remove(b.mesh));
        this.blocks = [];
        this.addBlock();
        this.scoreContainer.innerHTML = '0';
        this.stage.camera.position.y = 2;
    }

    startGame() {
        if (this.state !== this.STATES.PLAYING) {
            this.init();
            this.state = this.STATES.PLAYING;
            this.mainContainer.classList.remove('ended', 'ready');
            this.mainContainer.classList.add('playing');
            
            // Запуск музыки
            this.sounds.music.play().catch(e => console.log("Music blocked by browser"));
        }
    }

    handleAction() {
        if (this.state === this.STATES.PLAYING) this.placeBlock();
        else if (this.state === this.STATES.ENDED) this.startGame();
    }

    addBlock() {
        let lastBlock = this.blocks[this.blocks.length - 1];
        let newBlock = new Block(lastBlock);
        this.blocks.push(newBlock);
        this.stage.add(newBlock.mesh);
    }

    placeBlock() {
        let current = this.blocks[this.blocks.length - 1];
        let previous = this.blocks[this.blocks.length - 2];
        
        if (previous) {
            let diff = current.position[current.workingPlane] - previous.position[current.workingPlane];
            let maxDiff = current.workingDimension === 'width' ? current.dimension.width : current.dimension.depth;
            
            if (Math.abs(diff) >= maxDiff) {
                this.endGame();
                return;
            }
        }
        
        // Звук успешной установки
        this.sounds.place.currentTime = 0;
        this.sounds.place.play();

        this.addBlock();
        this.scoreContainer.innerHTML = this.blocks.length - 1;
        TweenLite.to(this.stage.camera.position, 0.4, { y: (this.blocks.length * 2) + 2 });
    }

    endGame() {
        this.state = this.STATES.ENDED;
        this.mainContainer.classList.add('ended');
        
        // Звук проигрыша и остановка музыки
        this.sounds.music.pause();
        this.sounds.fail.play();
        
        if (window.ysdk) {
            window.ysdk.adv.showFullscreenAdv({
                callbacks: {
                    onClose: () => { console.log("Adv closed"); },
                    onError: (err) => { console.log("Adv error", err); }
                }
            });
        }
    }

    tick() {
        if (this.state === this.STATES.PLAYING) {
            this.blocks[this.blocks.length - 1].tick();
        }
        this.stage.render();
        requestAnimationFrame(() => this.tick());
    }
}

const game = new Game();
